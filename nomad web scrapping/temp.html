<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div class="tt_article_useless_p_margin contents_style">            <div class="revenue_unit_wrap ">
        <div class="revenue_unit_item adsense  responsive">
             <div class="revenue_unit_info">반응형</div>
             <script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
             <ins class="adsbygoogle" style="display:block;" data-ad-host="ca-host-pub-9691043933427338" data-ad-client="ca-pub-9481476191157960" data-ad-format="auto"></ins>
             <script>(adsbygoogle = window.adsbygoogle || []).push({}); </script>
        </div>
     </div><p></p><figure class="imageblock alignCenter" width="400" height="267" alt="자바(JAVA)" style="width: 400px; height: 267px;" data-origin-width="960" data-origin-height="640"><span data-url="https://t1.daumcdn.net/cfile/tistory/997FC7415B739D671F" data-lightbox="lightbox" data-alt="자바(JAVA)"><img src="https://t1.daumcdn.net/cfile/tistory/997FC7415B739D671F" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F997FC7415B739D671F" width="400" height="267" alt="자바(JAVA)" style="width: 400px; height: 267px;" data-origin-width="960" data-origin-height="640"></span><figcaption>자바(JAVA)</figcaption></figure><p></p>
<p style="text-align: center; clear: none; float: none;">&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">JAVA라는 언어를 통해 코딩을 하고 있는 사람으로서 JAVA의 간단한 탄생배경&nbsp;그리고</span></p>
<p><span style="font-size: 11pt;">JAVA의 시작과 끝이라고 할 수 있는 JVM을 한 번 짚고넘어가려고 해요</span></p>
<p><span style="font-size: 11pt;">우선 JAVA의 탄생배경을&nbsp;좀 알고가면 이해하기 더 좋을 듯 싶어서 먼저 정리해 봅니다</span></p>
<p>&nbsp;</p>
<p id="snail00">목차는 다음과 같습니다</p>
<p>&nbsp;</p>
<blockquote data-ke-style="style3">1. JAVA 탄생 배경<br>2. 자바 코드(JAVA Code) 실행 과정<br>3. JVM 동작원리 및 기본개념<br>&nbsp; &nbsp; 3-1. 클래스 로더 (Class Loader)<br>&nbsp; &nbsp; 3-2. 런타임 데이터 영역(Runtime Data Area)<br>&nbsp; &nbsp; 3-3. 실행 엔진(Execution Engine)</blockquote>
<p>&nbsp;</p>
<h2 data-ke-size="size26">JAVA 탄생배경</h2>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">JAVA는 썬 마이크로시스템즈의 제임스 고슬링이라는 사람과 다른 연구원들이 개발한 프로그래밍 언어에요</span></p>
<p><span style="font-size: 11pt;">1991년 그린 프로젝트(Green Project)라는 이름으로 시작해 1995년에 발표가 됬는데요</span></p>
<p><span style="font-size: 11pt;">&nbsp;</span></p>
<p><span style="font-size: 11pt;">처음에는 가전제품 내에 탑재해 동작하는 프로그램을 위해 개발했는데&nbsp;</span><span style="font-size: 11pt;">아이러니하게도 현재는 웹 어플리케이션 개발에 가장 많이 사용하는 언어 중에 하나가 되어있죠&nbsp;</span><span style="font-size: 11pt;">(물론 모바일 기기용 소프트웨어 개발에도 널리 사용되고 있구요)</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">소문에 의하면 제임스고슬링이라는 사람이 가전제품 내에 탑재해 동작하는 프로그램을 개발하려고 하는데&nbsp;</span><span style="font-size: 11pt;">그 당시에는 유닉스 기반의 배경을 가지고 있었기 때문에 사용하던 프로그래밍 언어 C/C++의 특성상 여러 하드웨어를 커버하기에는&nbsp;</span><span style="font-size: 11pt;">같은 기능의 소스를 각 하드웨어에 맞게 작성해야하는 번거로움이 있어서 JAVA를 개발하게 되었다고해요</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">JAVA의 가장 큰 특징 중 하나가 바로 어느 플랫폼,&nbsp;</span><span style="font-size: 11pt;">그러니까 어느 하드웨어(CPU)던, 어느 운영체제(OS)이던 상관없이&nbsp;</span><span style="font-size: 11pt;">컴파일된 코드(바이트코드)가 플랫폼 독립적이라는 점이에요.&nbsp;</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">다시 말해서 어느 플랫폼이든 작성한 소스를 변경할 필요 없이 다 실행시킬 수 있다는 것이죠&nbsp;</span><span style="font-size: 11pt;">그리고 바로 이 점이 웹 어플리케이션의 특성과 맞아 떨어져 폭발적인 인기와 함께&nbsp;</span><span style="font-size: 11pt;">현재 웹 어플리케이션 개발에 가장 많이 사용되는 언어 중에 하나가 되었습니다</span></p>
<p>&nbsp;</p>
<p></p><figure class="imageblock alignCenter" width="735" height="495" data-origin-width="735" data-origin-height="495"><span data-url="https://t1.daumcdn.net/cfile/tistory/99C2FC4F5B73C9812A" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/99C2FC4F5B73C9812A" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99C2FC4F5B73C9812A" width="735" height="495" data-origin-width="735" data-origin-height="495"></span></figure><p></p>
<p style="text-align: center; clear: none; float: none;">&nbsp;</p>
<p style="text-align: center; clear: none; float: none;">&nbsp;</p>
<p><span style="font-size: 11pt;">이러한 특징을 구현하기 위해서는 바로 오늘의 주제인 JVM(JAVA Virtual Machine)이 필요합니다&nbsp;</span><span style="font-size: 11pt;">JVM, 자바 가상 머신은 단순하게 말하면 컴파일된 코드(바이트코드)를 실행시켜주는&nbsp;</span><span style="font-size: 11pt;">가상의 컴퓨터라고 생각하시면 다음 글을 이해하기 쉬울거에요</span></p>
<p><span style="font-size: 11pt;">(참고로 JVM은 H/W와 OS 위에서 실행되기 때문에 JVM 자체는 플랫폼에 종속적 즉, 플랫폼에 따라 호환되는 JVM을 실행시켜줘야함)</span></p>
<p>&nbsp;</p>
<h2 data-ke-size="size26">자바 코드(JAVA Code) 실행 과정</h2>
<p><span style="font-size: 11pt;">JVM의 속을 들여다 보기 전에 JVM에게 코드가 전달되기 까지의 과정을 간단하게 살펴보려고 해요</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p></p><figure class="imageblock alignCenter" width="823" height="696" alt="자바 코드(JAVA Code) 실행과정" data-origin-width="823" data-origin-height="696"><span data-url="https://t1.daumcdn.net/cfile/tistory/99A840415B739DF119" data-lightbox="lightbox" data-alt="자바 코드(JAVA Code) 실행과정"><img src="https://t1.daumcdn.net/cfile/tistory/99A840415B739DF119" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99A840415B739DF119" width="823" height="696" alt="자바 코드(JAVA Code) 실행과정" data-origin-width="823" data-origin-height="696"></span><figcaption>자바 코드(JAVA Code) 실행과정</figcaption></figure><p></p>
<p style="text-align: center; clear: none; float: none;">&nbsp;</p>
<p style="text-align: center; clear: none; float: none;">&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">위의 그림을 보면 어떤식으로 돌아가는지 한 눈에 알 수 있는데요 단계별로 짚어볼게요</span></p>
<p>&nbsp;</p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">1) 작성한 자바소스(JAVA Source), 즉 확장자가 .java인 파일을 자바 컴파일러(JAVA Compiler)를 통해 자바 바이트코드(JAVA Byte Code)로 컴파일한다.</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">2) 컴파일된 바이트코드를 JVM의 클래스로더(Class Loader)에게 전달한다.</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">3) 클래스로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data area), 즉 JVM의 메모리에 올린다.</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">4) 실행엔진(Execution Engine)은 JVM메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다.</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">이제 작성한 자바 소스가 어떻게 동작하는 건지 파악했으니 본격적으로 JVM의 속을 들여다 볼게요</span></p>
<p>&nbsp;</p>
<p></p><figure class="imageblock alignCenter" width="616" height="514" alt="JRE 안에 있는 JVM" data-origin-width="616" data-origin-height="514"><span data-url="https://t1.daumcdn.net/cfile/tistory/990BF73B5B73A02817" data-lightbox="lightbox" data-alt="JRE 안에 있는 JVM"><img src="https://t1.daumcdn.net/cfile/tistory/990BF73B5B73A02817" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F990BF73B5B73A02817" width="616" height="514" alt="JRE 안에 있는 JVM" data-origin-width="616" data-origin-height="514"></span><figcaption>JRE 안에 있는 JVM</figcaption></figure><p></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 data-ke-size="size26">JVM 동작원리 및 기본개념</h2>
<p><span style="font-size: 11pt;">JVM은 JAVA의 처음이자 끝이기 때문에 오늘 정리한 내용만으로 다 정리했다는 생각은 절대 하지 않고&nbsp;</span><span style="font-size: 11pt;">차츰 차츰 더 자세히 그리고 완벽히 정리할 예정이에요&nbsp;</span><span style="font-size: 11pt;">오늘은 맛보기로 어떻게 구성되어 있으며 각 구성원들이 어떻게 동작하는지에 대해서 정리하려고 합니다</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">순서는 다음과 같이</span></p>
<p>&nbsp;</p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">1) 클래스 로더 ( Class Loader )</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">2) 런타임 데이터 영역 ( Runtime Data Area )</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">3) 실행 엔진 ( Execution Engine )</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 data-ke-size="size26">클래스 로더 (Class loader)</h2>
<p><span style="font-size: 11pt;">클래스 로더의 특징은 크게 보면 5가지로 나눌 수 있어요</span></p>
<p>&nbsp;</p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">1 - 계층구조</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">2 - 위임모델</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">3 - 가시성 제한</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">4 - 언로드(Unload) 불가</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">5 - 이름공간(Name Space)</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">동적로딩도 모르던 나에게 클래스로더도 생소했지만 각 특징들을 차례대로 정리해볼게요</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 data-ke-size="size26">1 - 계층구조</h2>
<p></p><figure class="imageblock alignCenter" width="606" height="518" alt="클래스 로더(Class Loader) 계층구조" data-origin-width="606" data-origin-height="518"><span data-url="https://t1.daumcdn.net/cfile/tistory/99DBA04D5B73A37321" data-lightbox="lightbox" data-alt="클래스 로더(Class Loader) 계층구조"><img src="https://t1.daumcdn.net/cfile/tistory/99DBA04D5B73A37321" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99DBA04D5B73A37321" width="606" height="518" alt="클래스 로더(Class Loader) 계층구조" data-origin-width="606" data-origin-height="518"></span><figcaption>클래스 로더(Class Loader) 계층구조</figcaption></figure><p></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">클래스 로더는 단순하게 하나로 이루어져 있지 않아요&nbsp;</span><span style="font-size: 11pt;">위의 그림처럼 여러 클래스 로더끼리 부모-자식 관계를 이루고 있어서 계층적인 구조로 되어 있는데요&nbsp;</span><span style="font-size: 11pt;">각 클래스로더들을 정리하자면 다음과 같아요</span></p>
<p>&nbsp;</p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">· 부트스트랩 클래스 로더(Bootstrap Class Loader)</span></p>
<p style="margin-left: 4em;"><span style="font-size: 11pt;">- 최상위 클래스로더로 유일하게 JAVA가 아니라&nbsp;네이티브 코드로 구현이 되어있다.</span></p>
<p style="margin-left: 4em;"><span style="font-size: 11pt;">- JVM이 실행될 때 같이 메모리에 올라간다</span></p>
<p style="margin-left: 4em;"><span style="font-size: 11pt;">- Object 클래스를 비롯하여 JAVA API들을 로드한다.</span></p>
<p style="margin-left: 4em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">· 익스텐션 클래스 로더(Extension Class Loader)</span></p>
<p style="margin-left: 4em;"><span style="font-size: 11pt;">- 기본 JAVA API를 제외한 확장 클래스들을 로드한다. (다양한 보안 확장기능 로드)</span></p>
<p style="margin-left: 4em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">· 시스템 클래스 로더(System Class Loader)</span></p>
<p style="margin-left: 4em;"><span style="font-size: 11pt;">- 부트스트랩과 익스텐션 클래스로더가 JVM 자체의 구성요소들을 로드한다면, 시스템 클래스 로더는 어플리케이션의 클래스들을 로드한다.</span></p>
<p style="margin-left: 4em;"><span style="font-size: 11pt;">- 사용자가 지정한 $CLASSPATH 내의 클래스들을 로드한다.</span></p>
<p style="margin-left: 4em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">· 사용자 정의&nbsp;클래스 로더(User-Defined Class Loader)</span></p>
<p style="margin-left: 4em;"><span style="font-size: 11pt;">- 어플리케이션 사용자가 직접 코드상에서 생성하여 사용하는 클래스로더.</span></p>
<p style="margin-left: 4em;">&nbsp;</p>
<p><span style="font-size: 11pt;">웹 어플리케이션 서버(Web Application Server : WAS)와 같은 프레임 워크는 웹 어플리케이션, 엔터프라이즈 어플리케이션이&nbsp;</span><span style="font-size: 11pt;">서로 독릭접으로 동작하게 하기 위해서 사용자 정의 클래스 로더들을 사용하여&nbsp;</span><span style="font-size: 11pt;">클래스 로더의 위임 모델을 통해 어플리케이션의 독립성을 보장한다고 해요</span></p>
<p><span style="font-size: 11pt;">&nbsp;</span></p>
<p><span style="font-size: 11pt;">따라서 WAS의 클래스 로더 구조는 WAS벤더마다 조금씩 다른 형태의 계층 구조를 사용하고 있다고 합니다</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 data-ke-size="size26">2 - 위임모델</h2>
<p></p><figure class="imageblock alignCenter" width="610" height="518" alt="클래스 로더(Class Loader) 위임모델" data-origin-width="610" data-origin-height="518"><span data-url="https://t1.daumcdn.net/cfile/tistory/99644E3E5B73BA5D36" data-lightbox="lightbox" data-alt="클래스 로더(Class Loader) 위임모델"><img src="https://t1.daumcdn.net/cfile/tistory/99644E3E5B73BA5D36" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99644E3E5B73BA5D36" width="610" height="518" alt="클래스 로더(Class Loader) 위임모델" data-origin-width="610" data-origin-height="518"></span><figcaption>클래스 로더(Class Loader) 위임모델</figcaption></figure><p></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">위임모델이란 처음 바이트코드를 넘겨받은 클래스 로더가 필요한 클래스를 로드할 때 혹은&nbsp;</span><span style="font-size: 11pt;">실행엔진에서 명령어 단위로 바이트코드를 실행하다가 처음으로 참조하는 클래스에 대해 클래스 로더에게 로드를 요청할 때&nbsp;</span><span style="font-size: 11pt;">로드를 요청받은 클래스 로더는 다음 순서대로 요청받은&nbsp;클래스가 있는지 확인해요</span></p>
<p>&nbsp;</p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">1 - 클래스 로더 캐시</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">2 - 상위 클래스 로더</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">3 - 자기 자신</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">이전에 로드된 클래스인지 클래스 로더 캐시를 확인하고, 없으면 상위 클래스 로더를 하나씩 거슬러 올라가며 확인하는데 이 때 중요한 점은&nbsp;</span><span style="font-size: 11pt;">올라가는 도중에 클래스를 발견하더라도 부트스트랩 클래스 로더까지 확인을 해서 부트스트랩 클래스 로더에도 해당 클래스가 존재하면&nbsp;</span><span style="font-size: 11pt;">부트스트랩 클래스 로더에 있는 클래스를 로드한다는 점이에요</span></p>
<p><span style="font-size: 11pt;">&nbsp;</span></p>
<p><span style="font-size: 11pt;">예를들어, 요청 받은 클래스가 시스템 클래스 로더에 존재하여도 부트스트랩 클래스 로더까지 확인을 하고&nbsp;</span><span style="font-size: 11pt;">부트스트랩에도 해당 클래스가 존재하면 부트스트랩에 있는 클래스를 로드하게 되는거죠</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">이러한 특성으로 인해서 아키텍처를 구성하는 수준의 개발자라면 JVM에 대한 지식이 꼭 필요한 거겠죠</span></p>
<p><span style="font-size: 11pt;">(참고로 IBM에서 만든 어떤 WAS는 옵션을 통해서 중간에 클래스를 발견하면 부트스트랩 클래스 로더까지 올라가지 않도록 할 수 있도록 했다고 해요)</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">마지막으로 부트스트랩 클래스 로더에도 해당 클래스가 없으면 로드를 요청받은 클래스 로더가&nbsp;</span><span style="font-size: 11pt;">파일 시스템에서 해당 클래스를 찾는것으로 마무리 됩니다</span></p>
<p><span style="font-size: 11pt;">(파일 시스템에서도 찾지 못하면 클래스를 찾지 못했다는 예외가 발생하겠죠?)</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 data-ke-size="size26">3 - 가시성 제한</h2>
<p><span style="font-size: 11pt;">앞에 두 특징보다는 조금 간단한 특징인데요&nbsp;</span><span style="font-size: 11pt;">클래스 로더가 클래스 로드를 요청받았을 때 위임모델에 의해서 클래스 로더 캐시를 확인하고 없으면 상위 클래스 로더를 확인하는데&nbsp;</span><span style="font-size: 11pt;">이 때 하위 클래스 로더에 있는 클래스는 확인이 불가능한 특성이 바로 가시성 제한입니다</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">이러한 특성 또한 JVM을 공부해야하는 이유가 되겠죠</span></p>
<p>&nbsp;</p>
<h2 data-ke-size="size26">4 - 언로드(Unload) 불가</h2>
<p><span style="font-size: 11pt;">언로드 불가 역시 간단한 개념으로 말 그대로 클래스를 로드하는 것은 가능하지만&nbsp;</span><span style="font-size: 11pt;">반대로 언로드(Unload)하는 것은 불가능하다는 특성입니다</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 data-ke-size="size26">5 - 이름공간(Name space)</h2>
<p><span style="font-size: 11pt;">네임스페이스란 각 클래스 로더들이 가지고 있는 공간으로써 로드된 클래스를 보관하는 공간이에요&nbsp;</span><span style="font-size: 11pt;">클래스를 로드할 때 위임 모델을 통해서 상위 클래스 로더들을 확인하는데 그 때 확인하는 공간이 바로 네임스페이스입니다&nbsp;</span><span style="font-size: 11pt;">네임스페이스에 보관되는 기준은 FQCN(Fully Qualified Class Name)을 기준으로 보관되는데 FQCN이란 패키지명까지 포함되어있는 식별자를 뜻해요</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">각각의 클래스 로더가 각자 네임스페이스를 가지고 있기 때문에&nbsp;</span><span style="font-size: 11pt;">패키지명까지 같은 즉, FQCN이 같은 클래스라도 네임스페이스가 다르면(다른 클래스 로더가 로드한 클래스이면) 다른 클래스로 간주하는것이죠</span></p>
<p><span style="font-size: 11pt;">(이 특성을 이용하면 언로드를 대신해서 로드한 클래스 로더를 제거하면 마치 언로드한 것과 같은 효과를 줄 수 있습니다)</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 data-ke-size="size26">클래스 로드 과정</h2>
<p><span style="font-size: 11pt;">클래스 로더가 아직 로드되지 않은 클래스를 로드하는 과정을 간단하게 살펴보면</span></p>
<p>&nbsp;</p>
<p></p><figure class="imageblock alignCenter" width="590" height="656" alt="클래스 로드 과정" data-origin-width="590" data-origin-height="656"><span data-url="https://t1.daumcdn.net/cfile/tistory/991BA2445B73CD1429" data-lightbox="lightbox" data-alt="클래스 로드 과정"><img src="https://t1.daumcdn.net/cfile/tistory/991BA2445B73CD1429" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F991BA2445B73CD1429" width="590" height="656" alt="클래스 로드 과정" data-origin-width="590" data-origin-height="656"></span><figcaption>클래스 로드 과정</figcaption></figure><p></p>
<p>&nbsp;</p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">1 - 로드 : 클래스 파일을 가져와서 JVM의 메모리에 로드한다.</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">2 - 검증 : 클래스 로드 전 과정 중에서 가장 복잡하고 시간이 많이 걸리는 과정으로 읽어들인 클래스가 자바 언어 명세(JAVA Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다.</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">3 - 준비 : 클래스가 필요로 하는 메모리를 할당한다. 필요한 메모리란 클래스에서 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조들 등등을 말한다.</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">4 - 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">5 - 초기화 : 클래스 변수들을 적절한 값으로 초기화한다. ( static 필드들을 설정된 값으로 초기화 등 )</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">(여기서 분석 과정에서 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다는데 이게 무슨 의미인지.. 아시는 분 댓글로 남겨주시면 감사하겠습니다ㅜㅜ)</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 data-ke-size="size26">런타임 데이터 영역(Runtime Data Area)</h2>
<p><span style="font-size: 11pt;">JVM이 OS위에서 실행되면서 할당받는 메모리 영역이 바로 런타임 데이터 영역(Runtime Data Area)이에요&nbsp;</span><span style="font-size: 11pt;">이 영역은 크게 5가지 조금 세분화하면 6가지 영역으로 나눌 수 있는데요</span></p>
<p>&nbsp;</p>
<p></p><figure class="imageblock alignCenter" width="764" height="729" data-origin-width="764" data-origin-height="729"><span data-url="https://t1.daumcdn.net/cfile/tistory/99B467465B73D15111" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/99B467465B73D15111" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99B467465B73D15111" width="764" height="729" data-origin-width="764" data-origin-height="729"></span></figure><p></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">이 중 PC 레지스터(PC Register), JVM 스택(JVM Stack), 네이티브 메서드 스택(Native Method Stack)은 스레드(Thread)마다 하나씩 생성되고&nbsp;</span><span style="font-size: 11pt;">힙(Heap), 메서드영역(Method Area)은 모든 스레드가 공유해서 사용되요</span></p>
<p><span style="font-size: 11pt;">&nbsp;</span></p>
<p><span style="font-size: 11pt;">각 영역을 정리해보면</span></p>
<p>&nbsp;</p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">· PC 레지스터(PC Register) : PC(Program Counter) 레지스터는 현재 수행 중인 명령의 주소를 가지며 스레드가 시작될 때 생성되며 각 스레드마다 하나씩 존재한다.</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">· JVM 스택(JVM Stack) : 스택 프레임(Stack Frame)이라는 구조체를 저장하는 스택이다. 예외 발생 시 printStackTrace() 메서드로 보여주는 Stack Trace의 각 라인 하나가 스택 프레임을 표현한다. JVM 스택 역시 PC 레지스터와 마찬가지로 스레드가 시작될 때 생성되며 각 스레드마다&nbsp;하나씩 존재한다.</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">· 네이티브 메서드 스택(Native Method Stack) : JAVA 외의 언어로 작성된 네이티브 코드를 위한 스택이다. JNI(JAVA Native Interface)를 통해 호출하는 C/C++ 등의 코드를 수행하기 위한 스택으로, 언어에 맞게 스택이 생성된다. (C면 C스택, C++이면 C++스택 생성)</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">· 힙 : 인스턴스 또는 객체를 저장하는 공간으로 가비지 컬렉션(Garbage Collection) 대상이다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이다. 힙 구성 방식이나 가비지 컬렉션 방법 등은 JVM 벤더들의 재량이다.</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">· 메서드 영역(Method Area) : 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드에 대한 정보, Static 변수, 메서드의 바이트 코드 등을 보관한다.</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">* 메서드 영역은 JVM벤더마다 다양한 형태로 구현할 수 있으며, 오라클 핫스팟 JVM(HotSpot JVM)에서는 흔히 Permanent Area, 혹은 Permanent Generation(PermGen) 이라고 불린다. 메서드 영역에 대한 가비지 컬렉션은 JVM 벤더의 선택 사항이다.</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">· 런타임 상수 풀(Runtime Constant Pool) : JVM 동작에서 가장 핵심적인 역할을 수행하는 곳으로 JVM 명세에서도 따로 중요하게 기술한다. 각 클래스와 인터페이스의 상수 뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블로 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다.</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 data-ke-size="size26">실행 엔진(Execution Engine)</h2>
<p><span style="font-size: 11pt;">실행 엔진은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행해요</span></p>
<p><span style="font-size: 11pt;">(CPU가 기계 명령어를 하나씩 실행하듯이)</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">바이트 코드의 각 명령어는 1바이트 크기의 OpCode(Operation Code)와 추가 피연산자로 이루어져 있어요&nbsp;</span><span style="font-size: 11pt;">실행 엔진은 하나의 OpCode를 가져와서 피연산자와 작업을 수행한 다음, 그 다음 OpCode를 수행하는 식으로 동작해요</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">이 수행 과정에서 실행 엔진은 바이트 코드를 기계가 실행할 수 있는 형태로 변경하는데 다음 두 가지 방식으로 변경해요</span></p>
<p>&nbsp;</p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">· 인터프리터 : 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나하나의 해석은 빠르지만 전체적인 실행 속도는 느리다는 단점을 가진다. JVM안에서 바이트코드는 기본적으로 인터프리터 방식으로 동작한다.&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">&nbsp;</span></p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">· JIT 컴파일러(Just-In-Time Compiler) : 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 네이티브 코드로 변경하고 이후에는 해당 메서드를 더 이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식이다. 하나씩 인터프리팅하여 실행하는것이 아니라 바이트 코드 전체가 컴파일된 네이티브 코드를 실행하는 것이기 때문에 전체적인 실행 속도는 인터프리팅 방식보다 빠르다.</span></p>
<p style="margin-left: 2em;">&nbsp;</p>
<p></p><figure class="imageblock alignCenter" width="739" height="461" alt="자바 컴파일러(JAVA Compiler) / JIT 컴파일러(JIT Compiler)" data-origin-width="739" data-origin-height="461"><span data-url="https://t1.daumcdn.net/cfile/tistory/9949E83D5B73D7EA25" data-lightbox="lightbox" data-alt="자바 컴파일러(JAVA Compiler) / JIT 컴파일러(JIT Compiler)"><img src="https://t1.daumcdn.net/cfile/tistory/9949E83D5B73D7EA25" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F9949E83D5B73D7EA25" width="739" height="461" alt="자바 컴파일러(JAVA Compiler) / JIT 컴파일러(JIT Compiler)" data-origin-width="739" data-origin-height="461"></span><figcaption>자바 컴파일러(JAVA Compiler) / JIT 컴파일러(JIT Compiler)</figcaption></figure><p></p>
<p style="margin-left: 2em;">&nbsp;</p>
<p style="margin-left: 2em;"><span style="font-size: 11pt;">네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 캐시에서 바로 꺼내어 실행하기 때문에 빠르게 수행된다. 하지만 JIT 컴파일러가 컴파일하는 과정은 바이트 코드를 하나씩 인터프리팅 하는 것보다 훨씬 오래 걸리기 때문에 JIT 컴파일러를 사용하는 JVM은 내부적으로 해당 메서드가 얼마나 자주 호출되고 실행되는지 체크하고, 일정 기준을 넘었을 때에만 JIT 컴파일러를 통해 컴파일하여 네이티브 코드를 생성한다.</span></p>
<p style="margin-left: 2em;">&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">JIT 컴파일러를 통한 컴파일 과정은 바이트 코드를 바로 네이티브 코드로 만드는 것이 아니라&nbsp;</span><span style="font-size: 11pt;">안에서 IR(Intermediate Representation)로 변환하여 최적화를 수행하고 그 다음에 네이티브 코드로 변환는 과정을 거쳐요</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">오라클 핫스팟 VM은 핫스팟 컴파일러라고 불리는 JIT 컴파일러를 사용하는데 내부적으로 프로파일링(Profiling)을 통해&nbsp;</span><span style="font-size: 11pt;">가장 컴파일이 필요한 부분, 즉 '핫스팟'을 찾아낸 다음, 이 핫스팟을 컴파일하기 때문에 핫스팟이라 부른다고해요&nbsp;</span><span style="font-size: 11pt;">핫스팟 VM은 한 번 컴파일된 바이트코드라도 해당 메서드가 더 이상 자주 불리지 않는다면,&nbsp;</span><span style="font-size: 11pt;">캐시에서 네이티브 코드를 덜어내고 다시 인터프리터 모드로 동작해요</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">핫스팟 VM은 서버 VM과 클라이언트 VM으로 나뉘어 있고, 각각 다른 JIT 컴파일러를 사용해요&nbsp;</span><span style="font-size: 11pt;">각각은 동일한 런타임을 사용하지만, 다른 JIT 컴파일러를 사용해요&nbsp;</span><span style="font-size: 11pt;">서버 VM에서 사용되는 컴파일러가 더 복잡하고 다양한 성능 최적화 기법을 사용하고 있어요</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">이상 글을 마치며,, 이렇게 긴 글을 써보는건 처음인데 생각보다 오래 걸리네요</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 11pt;">부족한 글 끝까지 봐주셔서 감사합니다.</span></p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style2">
<p><span style="font-size: 11pt;">이 글은 </span><span style="font-size: 11pt;"><a class="tx-link" href="https://d2.naver.com/helloworld/1230" target="_blank" rel="noopener">네이버 D2</a></span><span style="font-size: 11pt;"><a class="tx-link" href="https://d2.naver.com/helloworld/1230" target="_blank" rel="noopener">&nbsp;JVM Internal</a></span><span style="font-size: 11pt;">을&nbsp;참조하여 작성하였습니다.</span></p>
<p>&nbsp;</p>            <div class="revenue_unit_wrap ">
        <div class="revenue_unit_item adsense  responsive">
             <div class="revenue_unit_info">반응형</div>
             <script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
             <ins class="adsbygoogle" style="display:block;" data-ad-host="ca-host-pub-9691043933427338" data-ad-client="ca-pub-9481476191157960" data-ad-format="auto"></ins>
             <script>(adsbygoogle = window.adsbygoogle || []).push({}); </script>
        </div>
     </div><div class="container_postbtn #post_button_group">
<div class="postbtn_like">
 
<script>
window.ReactionButtonType = 'reaction';
window.ReactionApiUrl = '//steady-snail.tistory.com/reaction';
window.ReactionReqBody = {
 entryId: 67    }
</script>
<div class="wrap_btn" id="reaction-67"><button class="btn_post uoc-icon"><div class="uoc-icon"><span class="ico_postbtn ico_like">좋아요</span><span class="txt_like uoc-count">14</span></div></button></div>
<script src="https://t1.daumcdn.net/tistory_admin/assets/blog/tistory-781a2fc58aada6e05c18210484bdceb25dd1d2d2/blogs/script/reaction/reaction-button-container.min.js?_version_=tistory-781a2fc58aada6e05c18210484bdceb25dd1d2d2"></script>
 <div class="wrap_btn wrap_btn_share">
<button type="button" class="btn_post sns_btn btn_share" data-thumbnail-url="https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F997FC7415B739D671F" data-title="[JAVA] JVM 동작원리 및 기본개념" data-description="JAVA라는 언어를 통해 코딩을 하고 있는 사람으로서 JAVA의 간단한 탄생배경&nbsp;그리고 JAVA의 시작과 끝이라고 할 수 있는 JVM을 한 번 짚고넘어가려고 해요 우선 JAVA의 탄생배경을&nbsp;좀 알고가면 이해하기 더 좋.." data-profile-image="https://tistory3.daumcdn.net/tistory/2785698/attach/887ad3c5d5e646469a35537153f9da98" data-profile-name="dalpang.e" data-pc-url="https://steady-snail.tistory.com/67" data-relative-pc-url="/67" data-blog-title="dalpang.e">
 <span class="ico_postbtn ico_share">공유하기</span>
</button>
</div>
         <div class="wrap_btn wrap_btn_etc" data-entry-id="67" data-entry-visibility="public" data-category-visibility="public">
<button type="button" class="btn_post btn_etc2"><span class="ico_postbtn ico_etc">글 요소</span></button>
</div>
</div>
<button type="button" class="btn_menu_toolbar btn_subscription  #subscribe" data-blog-id="2785698" data-url="https://steady-snail.tistory.com/67" data-device="web_pc">
<em class="txt_state">구독하기</em>
<strong class="txt_tool_id">dalpang.e</strong>
<span class="img_common_tistory ico_check_type1"></span>
</button>
<div class="postbtn_ccl" data-ccl-type="5">
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ko" target="_blank" class="link_ccl">
 <span class="bundle_ccl">
     <span class="ico_postbtn ico_ccl1">저작자표시</span><span class="ico_postbtn ico_ccl2">비영리</span><span class="ico_postbtn ico_ccl4">동일조건</span>        </span>
</a>
</div>
<!--
<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="">
 <license rdf:resource="http://creativecommons.org/licenses/by-nc-sa/2.0/kr/" />
</Work>
<License rdf:about="http://creativecommons.org/licenses/by-nc-sa/">
 <permits rdf:resource="http://web.resource.org/cc/Reproduction"/>
 <permits rdf:resource="http://web.resource.org/cc/Distribution"/>
 <requires rdf:resource="http://web.resource.org/cc/Notice"/>
 <requires rdf:resource="http://web.resource.org/cc/Attribution"/>
                 <prohibits rdf:resource="http://web.resource.org/cc/CommercialUse"/>
     </License>
</rdf:RDF>
-->
</div></div>
</body>
</html>